package su.erik.tabledataloader;

import org.apache.ibatis.builder.xml.XMLMapperBuilder;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.logging.stdout.StdOutImpl;
import org.apache.ibatis.mapping.Environment;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.apache.ibatis.transaction.jdbc.JdbcTransactionFactory;
import org.h2.jdbcx.JdbcDataSource;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import su.erik.tabledataloader.config.Constant;
import su.erik.tabledataloader.dto.DataResponse;
import su.erik.tabledataloader.param.MapParam;

import java.io.InputStream;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

class RawTableDataLoaderMasterDetailTest {

    private static SqlSessionFactory sqlSessionFactory;

    @BeforeAll
    static void setupAll() throws Exception {
        JdbcDataSource ds = new JdbcDataSource();
        ds.setURL("jdbc:h2:mem:testdb_md;DB_CLOSE_DELAY=-1;MODE=Oracle;DATABASE_TO_UPPER=FALSE");
        ds.setUser("sa");

        Environment environment = new Environment("test", new JdbcTransactionFactory(), ds);
        Configuration configuration = new Configuration(environment);
        configuration.setLogImpl(StdOutImpl.class);

        loadXml(configuration, "com/puls/centralpricing/handlers/mapper/reuse/Common.xml");
        loadXml(configuration, "su/erik/tabledataloader/TestMapper.xml");

        sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);
    }

    private static void loadXml(Configuration configuration, String resource) throws Exception {
        try (InputStream is = Resources.getResourceAsStream(resource)) {
            if (is == null) throw new RuntimeException("Resource not found in classpath: " + resource);
            XMLMapperBuilder builder = new XMLMapperBuilder(is, configuration, resource, configuration.getSqlFragments());
            builder.parse();
        }
    }

    @Test
    @DisplayName("Master-Detail: Проверка базового вложения (Nesting)")
    void testBasicMasterDetailExpansion() {
        try (SqlSession session = sqlSessionFactory.openSession()) {
            TestMapper mapper = session.getMapper(TestMapper.class);
            
            // Генерируем данные: 10 мастеров (ID 1..10)
            // Дети будут с masterId 2..11
            MapParam param = new MapParam();
            param.filter("number", 10);

            RawTableDataLoader<Map<String, Object>> loader = RawTableDataLoader.create();
            
            DataResponse<Map<String, Object>> response = loader
                    .setMapParam(param)
                    .useToGetData(mapper::testSelect)
                    .useChildList(mapper::selectChild)
                    .build();
            
            // Проверяем мастера с ID=2 (у него должен быть ребенок)
            Map<String, Object> master2 = response.items().stream()
                    .filter(m -> ((Number) m.get(Constant.MASTER_ID)).intValue() == 2)
                    .findFirst().orElseThrow();

            assertTrue(master2.containsKey(Constant.EXPANDED_KEY));
            List<Map<String, Object>> children = (List<Map<String, Object>>) master2.get(Constant.EXPANDED_KEY);
            
            assertFalse(children.isEmpty(), "Мастер ID=2 должен иметь детей");
            assertEquals("Child №1", children.getFirst().get("subName"));
        }
    }

    @Test
    @DisplayName("Master-Detail: Проверка замещения родителя единственным потомком (Flattening)")
    void testFlatteningWhenSingleChildExists() {
        try (SqlSession session = sqlSessionFactory.openSession()) {
            TestMapper mapper = session.getMapper(TestMapper.class);
            
            MapParam param = new MapParam();
            param.filter("number", 2); 
            param.setLimit(1); // Ограничиваем до 1 ребенка, чтобы сработало замещение (Flattening)
            
            RawTableDataLoader<Map<String, Object>> loader = RawTableDataLoader.create();
            loader.replaceParentByChild(List.of(Constant.MASTER_ID));
            
            DataResponse<Map<String, Object>> response = loader
                    .setMapParam(param)
                    .useToGetData(mapper::testSelect)
                    .useChildList(mapper::selectChild)
                    .build();

            Map<String, Object> result = response.items().stream()
                    .filter(m -> ((Number) m.get(Constant.MASTER_ID)).intValue() == 2)
                    .findFirst().orElseThrow();

            assertFalse(result.containsKey("name"), "Поле родителя 'name' должно быть очищено");
            assertTrue(result.containsKey("subName"), "Поле ребенка 'subName' должно присутствовать");
            assertEquals("Child №1", result.get("subName"));
        }
    }

    @Test
    @DisplayName("Master-Detail: Проверка оптимизированного удаления полей из дочерних записей")
    void testFieldRemovalInMultipleChildren() {
        try (SqlSession session = sqlSessionFactory.openSession()) {
            TestMapper mapper = session.getMapper(TestMapper.class);
            
            MapParam param = new MapParam();
            param.filter("number", 2); // n=1,2 => оба дадут masterId=2

            RawTableDataLoader<Map<String, Object>> loader = RawTableDataLoader.create();
            loader.replaceParentByChild(List.of(Constant.MASTER_ID));

            DataResponse<Map<String, Object>> response = loader
                    .setMapParam(param)
                    .useToGetData(mapper::testSelect)
                    .useChildList(mapper::selectChild)
                    .build();

            Map<String, Object> master = response.items().stream()
                    .filter(m -> ((Number)m.get(Constant.MASTER_ID)).intValue() == 2)
                    .findFirst().orElseThrow();
                    
            List<Map<String, Object>> children = (List<Map<String, Object>>) master.get(Constant.EXPANDED_KEY);

            assertEquals(2, children.size(), "Должно быть 2 ребенка для masterId=2");
            assertFalse(children.getFirst().containsKey(Constant.MASTER_ID));
            assertFalse(children.get(1).containsKey(Constant.MASTER_ID));
        }
    }

    @Test
    @DisplayName("Master-Detail: Проверка наличия ключа расширения при наличии и отсутствии детей")
    void testEmptyChildListLegacySupport() {
        try (SqlSession session = sqlSessionFactory.openSession()) {
            TestMapper mapper = session.getMapper(TestMapper.class);
            
            // number=2: Мастера ID=1, 2. Дети n=1,2 -> masterId=2, 3.
            MapParam param = new MapParam();
            param.filter("number", 2); 

            RawTableDataLoader<Map<String, Object>> loader = RawTableDataLoader.create();

            DataResponse<Map<String, Object>> response = loader
                    .setMapParam(param)
                    .useToGetData(mapper::testSelect)
                    .useChildList(mapper::selectChild)
                    .build();

            // 1. Мастер ID=1: детей нет (т.к. мин masterId=2)
            Map<String, Object> master1 = response.items().stream()
                    .filter(m -> ((Number)m.get(Constant.MASTER_ID)).intValue() == 1)
                    .findFirst().orElseThrow();
            assertTrue(master1.containsKey(Constant.EXPANDED_KEY), "Ключ должен быть даже если детей нет");
            assertTrue(((List<?>) master1.get(Constant.EXPANDED_KEY)).isEmpty(), "Список детей должен быть пустым");

            // 2. Мастер ID=2: должен быть 1 ребенок (n=1)
            Map<String, Object> master2 = response.items().stream()
                    .filter(m -> ((Number)m.get(Constant.MASTER_ID)).intValue() == 2)
                    .findFirst().orElseThrow();
            assertTrue(master2.containsKey(Constant.EXPANDED_KEY));
            List<Map<String, Object>> children2 = (List<Map<String, Object>>) master2.get(Constant.EXPANDED_KEY);
            assertFalse(children2.isEmpty(), "Список детей не должен быть пустым");
            assertEquals("Child №1", children2.getFirst().get("subName"));
        }
    }
}