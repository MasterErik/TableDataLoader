package su.erik.tabledataloader.importer;

import com.puls.centralpricing.common.exception.StandardFault;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import su.erik.tabledataloader.config.Constant;
import su.erik.tabledataloader.importer.dto.ImportResultDTO;
import su.erik.tabledataloader.importer.dto.UploadDTO;

import java.io.IOException;
import java.io.InputStream;
import java.lang.invoke.MethodHandles;
import java.util.Map;

/**
 * Базовая реализация импортера файлов.
 * Выполняет:
 * 1. Вставку заголовка загрузки (UploadDTO).
 * 2. Построчное чтение файла через итератор.
 * 3. Передачу распарсенных DTO в ImportMapper.
 */
public abstract class AbstractFileImporter<T> implements FileImporter {

    private final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());

    protected final Class<T> importDTOClass;
    protected final ImportMapper<T> importMapper;
    protected final Map<String, Object> customFilters;

    public AbstractFileImporter(Class<T> importDTOClass, ImportMapper<T> importMapper, Map<String, Object> customFilters) {
        this.importDTOClass = importDTOClass;
        this.importMapper = importMapper;
        this.customFilters = customFilters;
    }

    /**
     * Создает итератор по объектам T из потока ввода.
     */
    protected abstract Iterable<T> iteratorBuilder(InputStream inputStream);

    @Override
    public ImportResultDTO importFile(InputStream inputStream, String name, long size, String entity, Long userId) {
        final var uploadId = insertHeader(inputStream, name, size, entity, userId);

        // Пробрасываем ID загрузки в фильтры для использования в MyBatis
        customFilters.put("uploadId", uploadId);

        final var count = importRecords(uploadId, inputStream);

        if (count > 0) {
            finish();
        }

        log.info("Upload finished, id:{} rows:{}", uploadId, count);
        return new ImportResultDTO(uploadId, count);
    }

    protected long insertHeader(InputStream inputStream, String name, long size, String entity, Long userId) {
        try {
            // Если размер неизвестен (0), пытаемся узнать available, хотя для потоков это ненадежно
            long actualSize = (size <= 0) ? inputStream.available() : size;

            // Дата создается внутри UploadDTO или в БД (default value)
            final var uploadDTO = new UploadDTO(name, userId, null, actualSize, entity);

            importMapper.insertHeader(uploadDTO);

            if (uploadDTO.getId() == null) {
                throw new StandardFault(new RuntimeException("UploadId wasn't generated by import mapper"));
            }

            log.info("Uploading {}, id:{} name:{} size:{}", entity, uploadDTO.getId(), name, actualSize);
            return uploadDTO.getId();
        } catch (IOException e) {
            throw new StandardFault(e);
        }
    }

    protected int importRecords(long uploadId, InputStream inputStream) {
        try {
            int count = 0;
            Iterable<T> iterator = iteratorBuilder(inputStream);

            for (T importDTO : iterator) {
                if (importDTO == null) continue;

                // Ключевая логика: кладем DTO в карту для MyBatis
                customFilters.put("importDTO", importDTO);

                insert();

                count++;
                if (count % Constant.DEFAULT_BATCH_SIZE == 0) {
                    importMapper.flush();
                }
            }
            // Финальный сброс буфера
            importMapper.flush();
            return count;
        } catch (RuntimeException e) {
            throw new StandardFault(e);
        }
    }

    protected void insert() {
        importMapper.insert(customFilters);
    }

    protected void finish() {
        importMapper.finish(customFilters);
    }
}
